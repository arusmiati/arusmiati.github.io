<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:400,500,600,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Rubik:500,700,900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
        ul {
            margin-left: 20px;
        }
        
        @media (max-width: 1199px) {
            ul {
                margin-left: 0px;
            }
        }
    </style>
    <title>PEMODELAN PROTOKOL KOMUNIKASI LAYER TRANSPORT MENGGUNAKAN FINITE STATE MACHINE</title>
</head>

<body>
    <div class="main-container">
        <div class="sidebar">
            <center>
                <h2>Andi Rusmiati</h2>
            </center>
            <a href="index.html"><i class="fa fa-home"></i><span>Home</span></a>
            <a href="about.html"><i class="fa fa-user"></i><span>About</span></a>
            <a href="network.html"><i class="fa fa-desktop"></i><span>Computer Network</span></a>
        </div>


        <div class="main-content">
            <section class="cn section shadow-dark">
                <div class="container">
                    <div class="row">

                        <div class="section-title padd-15">

                            <h2 class="title">PEMODELAN PROTOKOL KOMUNIKASI LAYER TRANSPORT MENGGUNAKAN FINITE STATE MACHINE (FSM)</h2><br>

                            <h4>Apa itu Finite State Machine?</h4>
                            <p>Finite State Machine (FSM) adalah rangkaian digital yang terdiri dari 3 bagian, yaitu Next-State Logic Circuit, State Memory Register dan Output Logic Circuit. Logic Circuit adalah rangkaian hasil implementasi persamaan logika,
                                sedangkan state memory register adalah sekumpulan Flip-Flop yang jumlahnya sama dengan jumlah bit feedback dan terkait dengan jumlah state. Misalnya jika jumlah state antara 5 sampai 8, maka jumlah feedbacknya harus terdiri
                                dari 3 Flip-Flop. Untuk sinkronisasi, State Memory Register dilengkapi dengan clock. Kecepatan clock (clock rate) tidak boleh melampaui waktu propagasi terpanjang pada Next-state logic circuit.<br><br> Definisi lain dari
                                FSM ialah FSM adalah sebuah metodologi perancangan sistem kontrol yang menggambarkan tingkah laku atau prinsip kerja sistem dengan menggunakan tiga hal berikut: State (keadaan), Event (kejadian) dan Action (aksi). FSM berfungsi
                                untuk mendefinisikan sekumpulan kondisi yang menentukan kapan suatu state harus berubah. Setiap state yang sedang dijalankan tersebut menentukan perilaku yang terjadi pada objek yang bersangkutan. Dalam state machine sistem
                                menempati satu state (keadaan). Sistem akan beralih atau bertransisi menuju ke state lain jika mendapatkan masukan event tertentu. Sistem akan tetap melakukan aksi yang sama pada suatu state sampai sistem menerima event
                                tertentu baik yang berasal dari perangkat luar atau komponen dari sistem itu sendiri. Setiap state terhubung oleh transisi dan setiap transisinya mengarah ke satu state lainnya. Transisi keaadan ini umumnya juga disertai
                                oleh aksi yang dilakukan oleh sistem ketika menanggapi masukan yang terjadi. Aksi yang dilakukan tersebut dapat berupa aksi sederhana yang melibatkan rangkaian proses yang relatif rumit. Diagram state FSM digambarkan pada
                                gambar sebagai berikut. </p>

                            <br>
                            <center><img src="icon/diagram.png" alt=""></center>
                            <p>Diagram tersebut memperlihatkan FSM dengan dua buah state dan dua buah input serta empat buah aksi output yang berbeda. Seperti terlihat pada gambar, ketika sistem mulai dihidupkan, sistem akan bertransisi menuju state0, pada
                                keadaan ini sistem akan menghasilkan Action1 jika terjadi masukan Event0, sedangkan jika terjadi Event1 maka Action2 akan dieksekusi kemudian sistem selanjutnya bertransisi ke keadaan State1 dan seterusnya</p>

                            <br>

                            <h4>Jenis-Jenis Finite State Machine (FSM)</h4>

                            <ol>
                                <li>FSM ber-output</li>
                                <p>FSM ber-output digunakan untuk merancang mesin atau sistem.</p>
                                <li>FSM tidak ber-output </li>
                                <p>FSM tidak ber-output digunakan untuk pengenalan bahasa dalam komputer, dengan input yang dimasukkan akan diperoleh apakah input tersebut dikenal oleh bahasa komputer atau tidak. Salah satu penggunaan FSM tidak ber-output
                                    adalah program compiler, yaitu program untuk memeriksa apakah perintah yang digunakan pengguna benar atau salah.</p>
                            </ol>


                            <h4>Reliable Data Transfer (rdt)</h4>
                            <p>Reliable Data Transfer (rdt) adalah suatu mekanisme TCP yang menyediakan komunikasi logis antara proses aplikasi yang berjalan pada host yang berbeda. dinamakan <b>reliabel</b> karena TCP menjamin bahwa data tersebut pasti
                                diterima sesuai dengan yang dikirimkan. Terdapat beberapa tipe rdt yaitu <b>rdt 1.0, rdt 2.1, rdt 2.2, rdt 3.0, dll</b>. Secara dasar, rdt menggunakan protokol stop-and-wait. Mekanismenya adalah setiap mengirim paket, sender
                                akan berhenti mengirim dan menunggu feedback dari penerima yang menandakan bahwa paket telah sampai tujuan. Namun, karena alasan jarak yang jauh, muncul berbagai versi update yang ada di rdt. </p>

                            <b><p>rdt3.0 = RDT over a Lossy Channel with Bit Errors</p></b>
                            <p>Pada proses rdt 3.0 pengiriman data dan ACK dilakukan secara berurutan tetapi tidak terdapat duplikasi data atau ACK seperti pada RDT 2.2. Pada versi ini, Sender dilengkapi dengan timer untuk ACK. Cara kerjanya adalah jika
                                ACK tidak tiba, maka paket tersebut akan dikirim ulang. Jika seandainya ACK tidak hilang, namun hanya terkena delay, maka hal ini akan menyebabkan paket terduplikasi. Namun, karena adanya field untuk sequence number, maka
                                paket tidak perlu diteruskan ke lapisan aplikasi.</p>

                            <h4>RDT 3.0 Dari sisi SENDER (PENGIRIM)</h4>
                            <center><img src="icon/rdt30sender.png" alt=""></center>
                            <p>Gambar diatas menunjukkan FSM untuk rdt 3.0 pada sisi pengirim (sender). Pada gambar tersebut, jelas bahwa terdapat 4 state yaitu state <b>wait for call 0 from above</b>, state <b>wait for ACK 0</b>, state <b>wait for call 1 from above</b>,
                                dan <b>state wait for ACK 0.</b></p>
                            <p>Adapun makna beberapa simbol diatas ialah:</p>
                            <ul>
                                <li>Tanda panah putus-putus : state awal dari FSM.</li>
                                <li>Tanda panah biru : transisi protokol dari 1 state ke state lain atau dari 1 state kembali ke state itu sendiri</li>
                                <li>Event: menyebabkan terjadinya transisi pada state, terletak di atas garis horizontal. Adapun contoh event pada gambar diatas yakni : <b>rdt_send(data), timeout, rdt_rcv(rcvpkt),dst.</b></li>
                                <li>Action : aksi/tindakan yang dilakukan jika terjadi event yg terdapat di bawah garis horizontal</li>
                                <li> ACK : Acknowledgment (tanda terima dari receiver).</li>
                                <li> ^ : tidak ada action yang dilakukan atau tidak ada event yang terjadi</li>
                            </ul>
                            <p><b>Prinsip Kerja rdt 3.0 dari sisi Sender</b></p>
                            <p>Proses pertama dimulai dari state <b>wait for call 0 from above</b> yang ditunjukkan oleh tanda panah putus-putus.</p>
                            <center><img src="icon/rdt.png" alt=""></center>
                            <p> Pada state ini, terdapat event <b>rdt_send(data)</b> yang artinya data dari application layer di oper turun ke transport layer. Hal ini menandakan bahwa data telah berada di transport layer. Event <b>rdt_send(data)</b> kemudian
                                diikuti oleh 3 tindakan yang dilaksanakan secara berurutan yaitu:
                                <ol>
                                    <li> <b>sndpkt=make_pkt(0,data,checksum)</b> yang berarti masukkan data ke dalam bentuk paket. Setelah data berada di transport layer maka data akan dimuat ke dalam bentuk paket dan diberi informasi-informasi tambahan. Sebuah
                                        paket berisi data itu sendiri, checksum, dan sequence number (pada status “wait for call 0 from above” sequence number = 0).</li>
                                    <li> <b>udt_send(sndpkt)</b> yang berarti paket ditransfer ke layer yang berada dibawah (network layer) untuk dikirimkan ke sisi penerima.</li>
                                    <li> <b>start_timer</b> yang berarti countdown time telah dimulai.</li>
                                </ol>
                            </p>
                            <p> Setelah start_timer dilaksanakan maka status akan segera berubah menjadi <b>wait for ACK 0</b>.</p>

                            <p>Selanjutnya proses kedua yaitu pada state <b>wait for ACK 0</b>.</p>
                            <center><img src="icon/rdt1.png" alt=""></center>
                            <p>Pada state ini terdapat 3 event, yaitu:
                                <ol>
                                    <li><b>rdt_rcv(rcvpkt) && (corrupt(rcvpkt)) || isACK(rcvpkt,1))</b>akan terjadi jika sisi sender menerima ack 1, padahal status saat ini ialah wait for ack 0 (menunggu ack 0). Itu berarti ack yang diterima oleh sender tidak
                                        sesuai harapan sehingga sender menganggap bahwa paket yang diterima oleh receiver corrupt ataupun ack yang diterima oleh sender corrupt. Pada event ini tidak dilakukan tindakan apapun (∧). State akan kembali menjadi
                                        <b>wait for ACK 0</b>. Lalu, menunggu sampai terjadi <b>timeout</b>.</li>
                                    <li><b>timeout</b>. Event ini menandakan bahwa waktu hitung mundur yang dimulai pada saat data dikirim telah habis sementara ACK 0 belum diterima oleh sender. Tindakan yang dilakukan pada event ini ialah :
                                        <ul>
                                            <li><b>udt_send(sndpkt)</b> yang berarti aksi protokol untuk melakukan pengiriman ulang paket.</li>
                                            <li><b>start_timer</b> merupakan tindakan untuk memulai kembali countdown time terhadap paket yang baru saja dikirim. Lalu protokol akan kembali pada status wait for ACK 0.</li>
                                        </ul>

                                    </li>
                                    <li><b>rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt,0)</b> merupakan event yang berarti bahwa paket ack telah diterima dan data tidak korup atau rusak serta ack bernilai 0 (sesuai harapan). Tindakan dari event
                                        ini ialah
                                        <b>stop_timer</b>, merupakan tindakan yang menghentikan countdown timer.

                                    </li>
                                </ol>
                            </p>
                            <p>Setelah stop_timer dilaksanakan maka status akan berubah menjadi <b>wait for call 1 from above.</b></p>

                            <p>Selanjutnya proses ketiga yaitu pada state <b>wait for call 1 from above</b>.</p>
                            <center><img src="icon/rdt2.png" alt=""></center>
                            <p>Pada state ini terdapat dua buah event, yaitu:
                                <ol>
                                    <li><b>rdt_send(data)</b>. Event pertama mirip dengan event pada state wait for call 0 from above dan telah dijelaskan sebelumnya. Perbedaanya hanya terletak pada sequence number. State <b>wait for call 1 from above</b>                                        akan mengirimkan paket dengan sequence number 1. Sehingga paket berisi data itu sendiri, checksum, dan sequence number bernilai 1. Lalu paket ini kemudian dikirimkan dengan action udt_send(sndpkt). Setelah itu start_timer
                                        akan dijalankan kemudian status akan berubah menjadi <b>wait for ACK 1.</b>
                                    </li>
                                    <li><b>rdt_rcv(rcvpkt) </b> merupakan event yang tidak diikuti oleh tindakan apapun (do nothing “∧”). Event ini akan terjadi pada kasus premature timeout seperti pada gambar dibawah ini.
                                        <center><img src="icon/timeout.PNG" alt=""></center>
                                        Pada gambar diatas terdapat pengiriman ack yang delay atau sampai saat countdown time telah expired sehingga sender mengirim 2 paket yang sama dan menerima 2 ACK untuk paket yang sama. Saat ACK pertama telah diterima maka status akan langsung berubah.
                                        Sehingga ACK kedua akan diterima pada status <b>wait for call 1 from above</b> danACK kedua ini akan diabaikan (do nothing)</li>
                                </ol>

                            </p>

                            <p>Next state yaitu <b> wait for ACK 1.</b></p>
                            <center><img src="icon/rdt3.png" alt=""></center>
                            <p>State ini mirip dengan state <b>wait for ACK 0.</b> Perbedaannya hanya terletak pada nilai sequence number yang ditunggu. Pada state ini protokol menunggu ACK dengan nilai 1. Jika ACK yang diterima ACK 0 maka state tidak akan
                                berubah dan akan menunggu hingga timeout, jika sudah timeout maka paket akan dikirim ulang. Jika ACK yang diterima ACK 1 maka timer akan dihentikan lalu state akan berubah menjadi
                                <b> wait for call 0 from above.</b>
                            </p>
                            <p>Siklus ini akan terus berulang dengan cara yang sama sampai pengirimian data selesai.</p>


                            <h4> RDT 3.0 Dari sisi RECEIVER (PENERIMA)</h4>
                            <center><img src="icon/rdtr.png" alt=""></center>
                            <p>Pada dasarnya FSM protokol komunikasi dari sisi penerima pada rdt 3.0 sama dengan FSM protokol komunikasi dari sisi penerima pada rdt 2.2. perbedaan dari rdt 3.0 dan rdt 2.2 hanya terletak pada sisi pengirim saja, yaitu adanya
                                penambahan timeout. Sedangkan sisi penerimanya tetap sama. Namun, adanya penambahan timeout pada sender side mengakibatkan adanya kemungkinan duplikat paket yang diterima receiver. Terdapat dua buah state pada FSM protokol
                                komunikasi diatas yaitu tate <b>Wait for 0 from below </b> dan <b>state Wait for 1 from below</b> serta terdapat dua event pada masing-masing state.</p>

                            <p><b>Prinsip Kerja rdt 3.0 dari sisi Receiver</b></p>
                            <p>Proses pertama dimulai dari state <b>wait for 0 from below</b> yang ditunjukkan oleh tanda panah putus-putus.</p>
                            <center><img src="icon/rdtr1.png" alt=""></center>
                            <p>Pada state ini terdapat event <b>rdt_rcv(rcvpkt && notcorrupt(rcvpkt) && has_seq0(rcvpkt) </b> yang artinya sebuah paket telah diterima dari layer bawah (network layer) dan paket itu tidak korup serta paket itu memiliki sequence
                                number 0 (sesuai dengan harapan), maka akan diambil 4 tindakan, yaitu :
                                <ol>
                                    <li>Mengekstrak paket sehingga menjadi data dengan tindakan <b>extract(rcvpkt,data).</b> </li>
                                    <li> Setelah itu data akan dioper ke layer atas (application layer) dengan tindakan <b>Deliver_data(data).</b> </li>
                                    <li> Kemudian, FSM protokol penerima akan membuat paket yang berisi ACK beserta sequence number 0 dan checksum dengan menggunakan tindakan <b>sndpkt=make_pkt(ACK,0,checksum).</b></li>
                                    <li>Terakhir, paket ACK ini akan di transfer ke layer bawah (network layer) untuk dikirimkan dengan <b>action udt_send(sndpkt).</b></li>
                                </ol>
                            </p>
                            <p>Setelah ke-empat action itu terlaksana maka status berubah menjadi <b>Wait for 1 from below.</b></p>

                            <p>Selanjutnya proses kedua yaitu pada state <b>wait for 1 from below</b>.</p>
                            <center><img src="icon/rdtr2.png" alt=""></center>
                            <p>Cara kerja state ini sama dengan state sebelumnya, hanya saja pada state ini sequence number yang diharapkan adalah 1. Sehingga, eventnya adalah <b>rdt_rcv(rcvpkt && notcorrupt(rcvpkt) && has_seq1(rcvpkt)</b> yang berati paket
                                telah diterima dan paket tidak korup serta paket memiliki sequence number 1 (sesuai harapan). Lalu ada 4 tindakan yang akan dilaksanakan yaitu mengekstrak paket , mentransfer data ke upper layer, membuat paket ACK 1, dan
                                yang terakhir mentransfer paket ke lower layer untuk dikirimkan.</p>

                            <p><i>Bagaimana jika ternyata paket korup atau terdapat duplikat paket pada receiver? </i></p>
                            <p>Maka, event yang akan terjadi adalah <b> rdt_rcv(rcvpkt && (corrupt(rcvpkt) || has_seq0(rcvpkt)).</b>Di dalam event ini terdapat dua kemungkinan yaitu, <b>rdt_rcv(rcvpkt) && (corrupt(rcvpkt))</b> yang berati paket telah diterima
                                namun paket tersebut corrupt atau kemungkinan kedua adalah <b>rdt_rcv(rcvpkt) && has_seq0(rcvpkt))</b> yang berarti paket telah diterima namun paket memiliki sequence number 0 (padahal paket yang diharapkan memiliki sequence
                                number 1). Kemungkinan kedua ini bisa mengindikasikan adanya duplicate packet yang diterima receiver. Baik kemungkinan pertama yang terjadi ataupun kemungkinan kedua yang terjadi, receiver akan melakukan tindakan yang sama
                                yaitu, <b>sndpkt=make_pkt(ACK,0,checksum)</b> serta <b> udt_send(sndpkt).</b>
                            </p>
                            <p>Ini berarti jika paket korup atau paket terdeteksi duplikat maka penerima tidak akan mengekstrak paket, penerima hanya akan mengirimkan ACK dengan sequence number 0. Begitu pula pada state <b>Wait for 0 from below,</b>jika
                                pada state ini paket korup atau duplikasi paket maka paket tidak akan diekstrak, lalu penerima hanya akan menigirim ack bernilai 1.</p>
                            <p> Siklus ini akan terus berlangsung sampai pengiriman data selesai.</p>

                            <br>
                            <p>Referensi:
                                <p> Kurose F. James, Keith W. Ross. 2005. Computer Networking. Unite States of Amerika: Pearson</p>
                            </p>
                        </div>
                    </div>
                </div>

            </section>
        </div>
    </div>
</body>

</html>
